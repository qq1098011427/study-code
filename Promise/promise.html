<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script src="./Promise.js"></script>
  <script>
    // 宏任务微任务的区分
    // [ ...] [ ...] [ ...] []代表宏任务，...代表微任务， 先执行宏任务，然后宏任务里的微任务，再执行宏任务以此循环
    // 宏任务可以理解为queue, 先进先执行  （script,  setTimeout）， 存在误差，因为队列要等待
    // 微任务可以理解为stack, 可以插对，后进先执行这样无误差，  （promise, MutationObserver）
    // console.log(1)
    // setTimeout(()=> {
    //   console.log(5)
    // })
    // const p = new Promisem((resolve,reject) => {
    //   // resolve('成功了')
    //   console.log(2)
    //   reject('err')
    // })
    // p.then(res => {
    //   console.log(4)
    //   console.log(res, '结果');
    // }, err => {
    //   console.log(4)
    //   console.log(err, '错误');
    // })
    // console.log(3, '同步')

    const p = new Promisem((resolve,reject) => {
      // setTimeout(() => {
      //   resolve('success1')
      //   resolve('success2')
      //   // reject('error1')
      //   // reject('error2')
      // }, 200)
      // resolve('success1')
      reject('error2')
    }) 
    // const p1 = p.then(res => console.log(res), err=> console.log(err, 'err'))

    // 多个then 扔进队列 循环调用
    // p.then(res => {
    //   console.log(res, 1)
    // }, err => {
    //   console.log(err, 1)
    // })
    // p.then(res => {
    //   console.log(res, 2)
    // }, err => {
    //   console.log(err, 2)
    // })

    // 链式 返回全新的Promise
    // let p1 = p.then(res => {
    //   console.log(res, '2')
    //   return new Promisem((resolve, reject) => {
    //     resolve('我是res2之后要打印的东西')
    //   })
    // }, err => {
    //   console.log(err, '2')
    //   return new Promisem((resolve, reject) => {
    //     resolve('我是res2之后要打印的东西')
    //   })
    // }).then(res => console.log(res, 'res1111'), err => console.log(err, 'err111'))

    // static
    // const p1 = Promisem.resolve(1).then(res => {
    //   console.log(res)
    // })
    // const p1 = Promisem.reject(2).then(res=> { return 3 }).catch(err => console.log('捕获', err))
    // const p1 = new Promisem((resolve, reject) => {
    //   setTimeout(()=> {
    //     resolve(1)
    //   }, 200)
    // })
    const p2 = new Promise((resolve, reject) => {
      setTimeout(()=> {
        reject(2)
      }, 100)
    }).then(res => {})
    // const p3 = Promisem.race([p1, p2])

    // const p4 = Promisem.all([p1, p2])

    // const p5 = Promisem.allSettled([p1, p2])

    // const p6 = p2.finally(() => {
    //   console.log('无论成功失败我都进行')
    // })
    Promise.prototype.catchm = function (cb) {
      return this.then(undefined, cb)
    }
    Promise.prototype.finallym = function (cb) {
      this.then(cb, cb)
      return this
    }
    console.dir(Promise);
    // const p3 = p2.catch(err=> { console.log(err, 'err11'); })
    // const p4 = p2.catchm(err=> { console.log(err, 'err11'); })
    const p3 = p2.finally(()=> { console.log('不管我在哪里我都进行'); })
    const p4 = p2.finallym(()=> { console.log('不管我在哪里我都进行'); })
    setTimeout(()=> {
        console.log(p3);
        console.log(p4);
      }, 300)
  </script>
</body>
</html>